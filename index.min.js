let g=null;const U=(e,t)=>{const n=t?async function(...r){return e.apply(this,r).result}:function(...r){return e.apply(this,r).result};return n.do=function(...r){const s=this==n?e(...r):e.apply(this,r),{result:o}=s;let i=!1;return{result:o,undo:()=>{i||(i=!0,s.undo())},get undone(){return i}}},n},B=e=>function(...t){const n=g,r=[];g=r;const s=e.apply(this,t);g=n;const o=s.then(u=>(n?.unshift(i),g=n,u)),i=()=>s.then(()=>r.forEach(u=>u()));return{result:o,undo:i}},T=e=>function(...t){const n=g,r=[];g=r;const s=e.apply(this,t),o=()=>r.forEach(i=>i());return n?.unshift(o),g=n,{result:s,undo:o}};w.define=e=>U(function(...t){const n=e.apply(this,t),{result:r,undo:s}=n;return g?.unshift(s),{result:r,undo:s}});function w(e){const t=e.constructor.name=="AsyncFunction";return U(t?B(e):T(e),t)}async function N(e){const t=g;return g=null,{then:r=>e.then(s=>(g=t,r(s)))}}const L=e=>(...t)=>e.forEach(n=>n(...t));function W(e){const t=w.define((s,o)=>{const i=[];let u;const f=y=>{if(i.push(y),!(i.length>1))return u=L(i),e.addEventListener(s,u,o),{then:f}};return{undo:()=>e.removeEventListener(s,u,o),result:{then:f,after:y=>(queueMicrotask(()=>queueMicrotask(y)),{then:f})}}}),n=w.define((s,o={})=>{const i=s[0].toUpperCase()+s.slice(1).toLowerCase(),u=window[i+"Observer"];if(!u)return;let f;const b=[],v=m=>{if(b.push(m),!(b.length>1))return f=new u(L(b)),f.observe(e,o),{then:v}};return{undo:()=>f.disconnect(),result:{then:v}}}),r=(s,o)=>{if(o=="does")return t;if(o=="observes"&&e instanceof Node)return n;const i=o.replace(/s$/,"");return u=>t(i,u)};return new Proxy({does:()=>{},observes:()=>{}},{get:r})}const A=Symbol("is-state-variable");function H(e){e!=null&&e[A]&&(e=e.get());const t={thing:e};return new d(t,"thing").proxy}class d extends EventTarget{static map=new WeakMap;static parentMap=new WeakMap;static proxyActions=["apply","construct","defineProperty","deleteProperty","get","getOwnPropertyDescriptor","getPrototypeOf","has","isExtensible","ownKeys","preventExtensions","set","setPrototypeOf"];object;key;callback;specials={valueOf:()=>this.value,toString:()=>this.value.toString(),get:()=>this.value,set:t=>{t!=null&&t[A]&&(t=t.get()),this.change(()=>this.object[this.key]=t)},delete:()=>this.change(()=>delete this.object[this.key]),typeof:()=>typeof this.value,addEventListener:(...t)=>this.addEventListener(...t),removeEventListener:(...t)=>this.removeEventListener(...t),dispatchEvent:(...t)=>this.dispatchEvent(...t)};constructor(t,n,r=null){d.map.has(t)||d.map.set(t,{});const s=d.map.get(t);if(s[n])return s[n];super();Object.assign(this,{object:t,key:n,callback:r}),s[n]=this,this.initialize(),this.changeValue(this.value)}get value(){return this.object[this.key]}get isObject(){return typeof this.value=="object"&&this.value!=null}get isArray(){return Array.isArray(this.value)}change(t){const n=this.value;t();const{value:r,key:s}=this;this.changeValue(r,n),this.dispatchValueChange(r,n),d.parentMap.get(this.object)?.forEach(o=>o.dispatchPropertyChange(s))}dispatchValueChange(t,n){if(t===n)return;const r={oldValue:n,value:t};this.dispatchEvent(new CustomEvent("valuechange",{detail:r})),this.dispatchEvent(new CustomEvent("change",{detail:r}))}dispatchPropertyChange(t){const n=t==null?{unknown:!0}:{property:t};this.dispatchEvent(new CustomEvent("propertychange",{detail:n})),this.dispatchEvent(new CustomEvent("change",{detail:n}))}changeValue(t,n){d.parentMap.get(n)?.delete(this),this.isObject&&(typeof t!="object"||t==null||(d.parentMap.has(t)||d.parentMap.set(t,new Set),d.parentMap.get(t).add(this)))}isPropertyReference(t){return this.isObject?this.isArray?typeof t=="symbol"?!1:!!(Number.isInteger(+t)&&t>=0):!0:!1}initialize(){const t=this.callback?function(){}:{},n={};n.get=(r,s)=>this.get(s),n.set=(r,s,o)=>(this.isPropertyReference(s)&&this.proxy[s].set(o),!0),n.deleteProperty=(r,s)=>{!this.isPropertyReference(s)||this.proxy[s].delete()},n.apply=(r,s,...o)=>this.callback.apply(s,...o);for(const r of d.proxyActions)n[r]??=(s,...o)=>Reflect[r](this.value,...o);this.proxy=new Proxy(t,n)}get(t){if(t==A)return!0;if(!this.isObject&&t==Symbol.toPrimitive)return()=>this.value;const n=this.specials[t];if((!this.isObject||this.isArray)&&n)return n;const r=this.getFlattenedValue(t);if(!this.isPropertyReference(t))return r;const s=this.value;return new d(s,t,n).proxy}getFlattenedValue(t){const n=this.value[t];return typeof n!="function"?n:this.isArray?(...r)=>this.callArrayMethod(this.value,t,...r):n.bind(this.value)}callArrayMethod(t,n,...r){const s=[...t],o=t,i=t[n](...r);if(!(s.length!=o.length||o.some((c,y)=>c!==s[y])))return i;const f=Math.max(s.length,o.length),b=[];for(let c=0;c<f;c++)o[c]!==s[c]&&b.push(c);for(const c of b)this.changeValue(o[c],s[c]);const v=d.map.get(t);for(const c of b)v?.[c]?.dispatchValueChange(o[c],s[c]);return d.parentMap.get(t)?.forEach(c=>c.dispatchPropertyChange()),i}}const P={url:"file:///Users/koen/Desktop/_personal/yozo/register.js",main:!1},K=new Set;async function Y(e,{as:t}={}){if(K.has(e.toString()))return;const r=await(await fetch(e)).text(),o=new DOMParser().parseFromString(r,"text/html"),i=o.querySelector("template"),u=o.querySelector("script"),f=o.querySelector("style"),b=i.getAttribute("mode")??"open",v=i.hasAttribute("delegates-focus"),c=f?new CSSStyleSheet:null,y=new Map,m=await G(u.textContent),{exposed:q,observed:$,form:D}=m,{internals:S,attributes:F,any:X,elements:I}=q;c?.replace(f.textContent),i.removeAttribute("mode"),i.removeAttribute("delegates-focus");const E=class extends HTMLElement{#t=null;[F]=(...a)=>{const p=new EventTarget;return y.set(a,p),p};[I]=Object.assign(a=>this[S].shadowRoot.querySelector(a),{all:a=>[...this[S].shadowRoot.querySelectorAll(a)]});constructor(){super();const a=this.attachShadow({mode:b,delegatesFocus:v});a.append(i.content.cloneNode(!0)),c&&(a.adoptedStyleSheets=[c]),this[S]=this.attachInternals(),m.construct?.call(this,this)}connectedCallback(){this.#t?.undo(),m.connect&&(this.#t=m.connect.do.call(this,this))}disconnectedCallback(){this.#t.undo(),m.disconnect?.()}attributeChangedCallback(a,p,O){if(p===O)return;const R={attribute:a,oldValue:p,value:O},V=()=>new CustomEvent("change",{detail:R});for(const[k,z]of y)(k.includes("*")||k.includes(a))&&z.dispatchEvent(V())}},M=(a,p)=>Object.defineProperty(E.prototype,a,p);for(const{name:a,method:p}of m.methods)M(a,{writable:!0,configurable:!0,value:p});for(const{name:a,descriptor:p}of m.properties)M(a,p);Object.defineProperty(E,"formAssociated",{get:()=>D}),Object.defineProperty(E,"observedAttributes",{get:()=>$}),customElements.define(t??m.name,E)}export{Y as register};const x=Symbol("secret");export{w as reversible,N as until};export{W as when};export{H as stateify};const l=e=>h.name=e,C=new Set,j=new Map;let h=null;l[x]={},l[x].getByUUID=e=>{const t=j.get(e);return j.delete(e),t},l[x].newContext=()=>({name:"",observed:[],properties:[],methods:[],form:!1,exposed:{internals:Symbol("internals"),attributes:Symbol("attributes"),any:Symbol("any"),elements:Symbol("elements")}}),l.context=e=>h?console.log({uuid:e}):(C.add(e),queueMicrotask(()=>{if(C.has(e))throw Error("Yozo: top level await not allowed in custom element definitions")}),h=l[x].newContext(),h.exposed),l.attribute=(e,t={})=>{if(h.observed.push(e),!t.type)return;const n=t.as??e.replace(/-+\w/g,s=>s.slice(-1).toUpperCase()),r=Array.isArray(n)?n:[n];for(const s of r)Q(e,{...t,as:s})},l.form=()=>{h.form=!0},l.property=(e,t)=>{typeof t=="function"&&(t={get:t}),h.properties.push({name:e,descriptor:t})},l.method=(e,t)=>{h.methods.push({name:e,method:t})},l.construct=e=>{h.construct=e},l.connect=e=>{h.connect=w(e)},l.disconnect=e=>{h.disconnect=e},l.done=(e,t)=>{if(!!h&&(C.delete(e),j.set(e,h),h=null,t))throw t};async function G(e){const t=crypto.randomUUID(),n="application/javascript",r=new Blob([J(e,t)],{type:n}),s=URL.createObjectURL(r);return await import(s),URL.revokeObjectURL(s),l[x].getByUUID(t)}const J=(e,t)=>`
import { define } from "${new URL("./define.js",P.url)}";
import { when } from "${new URL("./index.js",P.url)}";
const { internals, attributes, any, elements } = define.context('${t}');
const { construct, connect, disconnect } = define;
try {

${e}

} catch (error) { define.done('${t}', error); }
define.done('${t}');
`.slice(1);function Q(e,t){const{type:n,as:r}=t;n==Boolean?l.property(r,{get(){return this.hasAttribute(e)},set(s){this.toggleAttribute(e,s)}}):l.property(r,{get(){const s=this.getAttribute(e);return s==null?t.default??null:n(s)},set(s){if(s==null)return this.removeAttribute(e);this.setAttribute(e,s)}})}
