let b=null;const D=(e,t)=>{const s=t?async function(...r){return e.apply(this,r).result}:function(...r){return e.apply(this,r).result};return s.do=function(...r){const n=this==s?e(...r):e.apply(this,r),{result:o}=n;let c=!1;return{result:o,undo:()=>{c||(c=!0,n.undo())},get undone(){return c}}},s},B=e=>function(...t){const s=b,r=[];b=r;const n=e.apply(this,t);b=s;const o=n.then(l=>(s?.unshift(c),b=s,l)),c=()=>n.then(()=>r.forEach(l=>l()));return{result:o,undo:c}},N=e=>function(...t){const s=b,r=[];b=r;const n=e.apply(this,t),o=()=>r.forEach(c=>c());return s?.unshift(o),b=s,{result:n,undo:o}};S.define=e=>D(function(...t){const s=e.apply(this,t),{result:r,undo:n}=s;return b?.unshift(n),{result:r,undo:n}});function S(e){const t=e.constructor.name=="AsyncFunction";return D(t?B(e):N(e),t)}async function R(e){const t=b;return b=null,{then:r=>e.then(n=>(b=t,r(n)))}}const F=e=>(...t)=>e.forEach(s=>s(...t));function W(e){const t=S.define((n,o)=>{const c=[];let l,p=!1;const f=v=>(queueMicrotask(()=>queueMicrotask(v)),{then:i,timeout:y}),y=async v=>({then:C=>{const w=U=>{clearTimeout(M),e.removeEventListener(n,w,o),C(U)},M=setTimeout(()=>w(null),v);e.addEventListener(n,w,o)}}),i=v=>{if(c.push(v),p&&v(null),!(c.length>1))return l=F(c),e.addEventListener(n,l,o),{then:i}};return{undo:()=>e.removeEventListener(n,l,o),result:{now:()=>(p=!0,{then:i,after:f}),then:i,after:f,timeout:y}}}),s=S.define((n,o={})=>{const c=n[0].toUpperCase()+n.slice(1).toLowerCase(),l=globalThis[c+"Observer"];if(!l)return;let p;const f=[],y=g=>{if(f.push(g),!(f.length>1))return p=new l(F(f)),p.observe(e,o),{then:y}};return{undo:()=>p.disconnect(),result:{then:y}}}),r=(n,o)=>{if(o=="does")return t;if(o=="observes"&&e instanceof Node)return s;const c=o.replace(/s$/,"");return l=>t(c,l)};return new Proxy({does:()=>{},observes:()=>{}},{get:r})}const j=Symbol("is-state-variable");function H(e){e!=null&&e[j]&&(e=e.get());const t={thing:e};return new d(t,"thing").proxy}class d extends EventTarget{static map=new WeakMap;static parentMap=new WeakMap;static proxyActions=["apply","construct","defineProperty","deleteProperty","get","getOwnPropertyDescriptor","getPrototypeOf","has","isExtensible","ownKeys","preventExtensions","set","setPrototypeOf"];object;key;callback;specials={valueOf:()=>this.value,toString:()=>this.value.toString(),get:()=>this.value,set:t=>{t!=null&&t[j]&&(t=t.get()),this.change(()=>this.object[this.key]=t)},delete:()=>this.change(()=>delete this.object[this.key]),typeof:()=>typeof this.value,addEventListener:(...t)=>this.addEventListener(...t),removeEventListener:(...t)=>this.removeEventListener(...t),dispatchEvent:(...t)=>this.dispatchEvent(...t)};constructor(t,s,r=null){d.map.has(t)||d.map.set(t,{});const n=d.map.get(t);if(n[s])return n[s];super();Object.assign(this,{object:t,key:s,callback:r}),n[s]=this,this.initialize(),this.changeValue(this.value)}get value(){return this.object[this.key]}get isObject(){return typeof this.value=="object"&&this.value!=null}get isArray(){return Array.isArray(this.value)}change(t){const s=this.value;t();const{value:r,key:n}=this;this.changeValue(r,s),this.dispatchValueChange(r,s),d.parentMap.get(this.object)?.forEach(o=>o.dispatchPropertyChange(n))}dispatchValueChange(t,s){if(t===s)return;const r={oldValue:s,value:t};this.dispatchEvent(new CustomEvent("valuechange",{detail:r})),this.dispatchEvent(new CustomEvent("change",{detail:r}))}dispatchPropertyChange(t){const s=t==null?{unknown:!0}:{property:t};this.dispatchEvent(new CustomEvent("propertychange",{detail:s})),this.dispatchEvent(new CustomEvent("change",{detail:s}))}changeValue(t,s){d.parentMap.get(s)?.delete(this),this.isObject&&(typeof t!="object"||t==null||(d.parentMap.has(t)||d.parentMap.set(t,new Set),d.parentMap.get(t).add(this)))}isPropertyReference(t){return this.isObject?this.isArray?typeof t=="symbol"?!1:!!(Number.isInteger(+t)&&t>=0):!0:!1}initialize(){const t=this.callback?function(){}:{},s={};s.get=(r,n)=>this.get(n),s.set=(r,n,o)=>(this.isPropertyReference(n)&&this.proxy[n].set(o),!0),s.deleteProperty=(r,n)=>{!this.isPropertyReference(n)||this.proxy[n].delete()},s.apply=(r,n,...o)=>this.callback.apply(n,...o);for(const r of d.proxyActions)s[r]??=(n,...o)=>Reflect[r](this.value,...o);this.proxy=new Proxy(t,s)}get(t){if(t==j)return!0;if(!this.isObject&&t==Symbol.toPrimitive)return()=>this.value;const s=this.specials[t];if((!this.isObject||this.isArray)&&s)return s;const r=this.getFlattenedValue(t);if(!this.isPropertyReference(t))return r;const n=this.value;return new d(n,t,s).proxy}getFlattenedValue(t){const s=this.value[t];return typeof s!="function"?s:this.isArray?(...r)=>this.callArrayMethod(this.value,t,...r):s.bind(this.value)}callArrayMethod(t,s,...r){const n=[...t],o=t,c=t[s](...r);if(!(n.length!=o.length||o.some((i,E)=>i!==n[E])))return c;const p=Math.max(n.length,o.length),f=[];for(let i=0;i<p;i++)o[i]!==n[i]&&f.push(i);for(const i of f)this.changeValue(o[i],n[i]);const y=d.map.get(t);for(const i of f)y?.[i]?.dispatchValueChange(o[i],n[i]);return d.parentMap.get(t)?.forEach(i=>i.dispatchPropertyChange()),c}}const K=import.meta,Y=new Set,x=Symbol("secret"),a=e=>h.name=e,O=new Set,k=new Map;let h=null;a[x]={},a[x].getByUUID=e=>{const t=k.get(e);return k.delete(e),t},a[x].newContext=()=>({name:"",observed:[],properties:[],methods:[],form:!1,exposed:{internals:Symbol("internals"),attributes:Symbol("attributes"),any:Symbol("any"),elements:Symbol("elements")}}),a.context=e=>h?console.log({uuid:e}):(O.add(e),queueMicrotask(()=>{if(O.has(e))throw Error("Yozo: top level await not allowed in custom element definitions")}),h=a[x].newContext(),h.exposed),a.attribute=(e,t={})=>{if(h.observed.push(e),!t.type)return;const s=t.as??e.replace(/-+\w/g,n=>n.slice(-1).toUpperCase()),r=Array.isArray(s)?s:[s];for(const n of r)J(e,{...t,as:n})},a.form=()=>{h.form=!0},a.property=(e,t)=>{typeof t=="function"&&(t={get:t}),h.properties.push({name:e,descriptor:t})},a.method=(e,t)=>{h.methods.push({name:e,method:t})},a.construct=e=>{h.construct=e},a.connect=e=>{h.connect=S(e)},a.disconnect=e=>{h.disconnect=e},a.done=(e,t)=>{if(!!h&&(O.delete(e),k.set(e,h),h=null,t))throw t};export{a as define};async function G(e,{as:t}={}){if(Y.has(e.toString()))return;const r=await(await fetch(e)).text(),o=new DOMParser().parseFromString(r,"text/html"),c=o.querySelector("template"),l=o.querySelector("script"),p=o.querySelector("style"),f=c.getAttribute("mode")??"open",y=c.hasAttribute("delegates-focus"),i=p?new CSSStyleSheet:null,E=new Map,g=await Q(l.textContent),{exposed:L,observed:v,form:C}=g,{internals:w,attributes:M,any:U,elements:I}=L;i?.replace(p.textContent),c.removeAttribute("mode"),c.removeAttribute("delegates-focus");const A=class extends HTMLElement{#t=null;[M]=(...u)=>{const m=new EventTarget;return E.set(u,m),m};[I]=Object.assign(u=>this[w].shadowRoot.querySelector(u),{all:u=>[...this[w].shadowRoot.querySelectorAll(u)]});constructor(){super();const u=this.attachShadow({mode:f,delegatesFocus:y});u.append(c.content.cloneNode(!0)),i&&(u.adoptedStyleSheets=[i]),this[w]=this.attachInternals(),g.construct?.call(this,this)}connectedCallback(){this.#t?.undo(),g.connect&&(this.#t=g.connect.do.call(this,this))}disconnectedCallback(){this.#t.undo(),g.disconnect?.()}attributeChangedCallback(u,m,q){if(m===q)return;const $={attribute:u,oldValue:m,value:q},V=()=>new CustomEvent("change",{detail:$});for(const[T,z]of E)(T.includes("*")||T.includes(u))&&z.dispatchEvent(V())}},P=(u,m)=>Object.defineProperty(A.prototype,u,m);for(const{name:u,method:m}of g.methods)P(u,{writable:!0,configurable:!0,value:m});for(const{name:u,descriptor:m}of g.properties)P(u,m);Object.defineProperty(A,"formAssociated",{get:()=>C}),Object.defineProperty(A,"observedAttributes",{get:()=>v}),customElements.define(t??g.name,A)}export{G as register};export{S as reversible,R as until};export{W as when};export{H as stateify};a[x].url=K.url;function J(e,t){const{type:s,as:r}=t;s==Boolean?a.property(r,{get(){return this.hasAttribute(e)},set(n){this.toggleAttribute(e,n)}}):a.property(r,{get(){const n=this.getAttribute(e);return n==null?t.default??null:s(n)},set(n){if(n==null)return this.removeAttribute(e);this.setAttribute(e,n)}})}async function Q(e){const t=crypto.randomUUID(),s="application/javascript",r=new Blob([X(e,t)],{type:s}),n=URL.createObjectURL(r);return await import(n),URL.revokeObjectURL(n),a[x].getByUUID(t)}const X=(e,t)=>`
import { define, when } from "${a[x].url}";
const { internals, attributes, any, elements } = define.context('${t}');
const { construct, connect, disconnect } = define;
try {

${e}

} catch (error) { define.done('${t}', error); }
define.done('${t}');
`.slice(1);
