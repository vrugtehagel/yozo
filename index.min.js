let h=null;const M=(e,t)=>{const s=t?async function(...o){return e.apply(this,o).result}:function(...o){return e.apply(this,o).result};return s.do=function(...o){const n=this==s?e(...o):e.apply(this,o),{result:r}=n;let c=!1;return{result:r,undo:()=>{c||(c=!0,n.undo())},get undone(){return c}}},s},B=e=>function(...t){const s=h,o=[];h=o;const n=e.apply(this,t);h=s;const r=n.then(u=>(s?.unshift(c),h=s,u)),c=()=>n.then(()=>o.forEach(u=>u()));return{result:r,undo:c}},F=e=>function(...t){const s=h,o=[];h=o;const n=e.apply(this,t),r=()=>o.forEach(c=>c());return s?.unshift(r),h=s,{result:n,undo:r}};x.define=e=>M(function(...t){const s=e.apply(this,t),{result:o,undo:n}=s;return h?.unshift(n),{result:o,undo:n}});function x(e){const t=e.constructor.name=="AsyncFunction";return M(t?B(e):F(e),t)}async function N(e){const t=h;return h=null,{then:o=>e.then(n=>(h=t,o(n)))}}const q=e=>(...t)=>e.forEach(s=>s(...t));function z(e){const t=x.define((n,r)=>{const c=[];let u,p=!1;const b=y=>(queueMicrotask(()=>queueMicrotask(y)),{then:m,timeout:w}),w=async y=>({then:E=>{const g=j=>{clearTimeout(C),e.removeEventListener(n,g,r),E(j)},C=setTimeout(()=>g(null),y);e.addEventListener(n,g,r)}}),m=y=>{if(c.push(y),p&&y(null),!(c.length>1))return u=q(c),e.addEventListener(n,u,r),{then:m}};return{undo:()=>e.removeEventListener(n,u,r),result:{now:()=>(p=!0,{then:m,after:b}),then:m,after:b,timeout:w}}}),s=x.define((n,r={})=>{const c=n[0].toUpperCase()+n.slice(1).toLowerCase(),u=globalThis[c+"Observer"];if(!u)return;let p;const b=[],w=d=>{if(b.push(d),!(b.length>1))return p=new u(q(b)),p.observe(e,r),{then:w}};return{undo:()=>p.disconnect(),result:{then:w}}}),o=(n,r)=>{if(r=="does")return t;if(r=="observes"&&e instanceof Node)return s;const c=r.replace(/s$/,"");return u=>t(c,u)};return new Proxy({does:()=>{},observes:()=>{}},{get:o})}const H=import.meta,W=new Set,v=Symbol("secret"),i=e=>l.name=e,P=new Set,U=new Map;let l=null;i[v]={},i[v].getByUUID=e=>{const t=U.get(e);return U.delete(e),l=null,t},i[v].newContext=()=>({name:"",observed:[],properties:[],methods:[],form:!1,exposed:{internals:Symbol("internals"),attributes:Symbol("attributes"),any:Symbol("any"),elements:Symbol("elements")}}),i.context=e=>{if(l)throw Error(`Yozo: No top-level await`);return P.add(e),l=i[v].newContext(),l.exposed},i.attribute=(e,t={})=>{if(l.observed.push(e),!t.type)return;const s=t.as??e.replace(/-+\w/g,n=>n.slice(-1).toUpperCase()),o=Array.isArray(s)?s:[s];for(const n of o)_(e,{...t,as:n})},i.form=()=>{l.form=!0},i.property=(e,t)=>{typeof t=="function"&&(t={get:t}),l.properties.push({name:e,descriptor:t})},i.method=(e,t)=>{l.methods.push({name:e,method:t})},i.construct=e=>{l.construct=e},i.connect=e=>{l.connect=x(e)},i.disconnect=e=>{l.disconnect=e},i.done=(e,t)=>{if(!!l&&(P.delete(e),U.set(e,l),l=null,t))throw t};export{i as define};async function Y(e,{as:t}={}){if(W.has(e.toString()))return;const o=await(await fetch(e)).text(),r=new DOMParser().parseFromString(o,"text/html"),c=r.querySelector("template"),u=r.querySelector("script"),p=r.querySelector("style"),b=c.getAttribute("mode")??"open",w=c.hasAttribute("delegates-focus"),m=p?new CSSStyleSheet:null,S=new Map,d=await G(u.textContent);if(!d)return;const{exposed:L,observed:y,form:E}=d,{internals:g,attributes:C,any:j,elements:$}=L;m?.replace(p.textContent),c.removeAttribute("mode"),c.removeAttribute("delegates-focus");const A=class extends HTMLElement{#e=null;[C]=(...a)=>{const f=new EventTarget;return S.set(a,f),f};[$]=Object.assign(a=>this[g].shadowRoot.querySelector(a),{all:a=>[...this[g].shadowRoot.querySelectorAll(a)]});constructor(){super();const a=this.attachShadow({mode:b,delegatesFocus:w});a.append(c.content.cloneNode(!0)),m&&(a.adoptedStyleSheets=[m]),this[g]=this.attachInternals(),d.construct?.call(this,this)}connectedCallback(){this.#e?.undo(),d.connect&&(this.#e=d.connect.do.call(this,this))}disconnectedCallback(){this.#e.undo(),d.disconnect?.()}attributeChangedCallback(a,f,O){if(f===O)return;const T={attribute:a,oldValue:f,value:O},D=()=>new CustomEvent("change",{detail:T});for(const[R,I]of S)(R.includes("*")||R.includes(a))&&I.dispatchEvent(D())}},k=(a,f)=>Object.defineProperty(A.prototype,a,f);for(const{name:a,method:f}of d.methods)k(a,{writable:!0,configurable:!0,value:f});for(const{name:a,descriptor:f}of d.properties)k(a,f);Object.defineProperty(A,"formAssociated",{get:()=>E}),Object.defineProperty(A,"observedAttributes",{get:()=>y}),customElements.define(t??d.name,A)}export{Y as register};export{x as reversible,N as until};export{z as when};i[v].url=H.url;function _(e,t){const{type:s,as:o}=t;s==Boolean?i.property(o,{get(){return this.hasAttribute(e)},set(n){this.toggleAttribute(e,n)}}):i.property(o,{get(){const n=this.getAttribute(e);return n==null?t.default??null:s(n)},set(n){if(n==null)return this.removeAttribute(e);this.setAttribute(e,n)}})}async function G(e){const t=crypto.randomUUID(),s="application/javascript",o=new Blob([J(e,t)],{type:s}),n=URL.createObjectURL(o);let r;await import(n).catch(u=>r=u),URL.revokeObjectURL(n);const c=i[v].getByUUID(t);if(r)throw r;return c}const J=(e,t)=>`
import { define, when } from "${i[v].url}";
const { internals, attributes, any, elements } = define.context('${t}');
const { construct, connect, disconnect } = define;

${e}

define.done('${t}');
`.slice(1);
