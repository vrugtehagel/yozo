let h=null;const P=(e,t)=>{const s=t?async function(...o){return e.apply(this,o).result}:function(...o){return e.apply(this,o).result};return s.do=function(...o){const n=this==s?e(...o):e.apply(this,o),{result:r}=n;let c=!1;return{result:r,undo:()=>{c||(c=!0,n.undo())},get undone(){return c}}},s},W=e=>function(...t){const s=h,o=[];h=o;const n=e.apply(this,t);h=s;const r=n.then(d=>(s?.unshift(c),h=s,d)),c=()=>n.then(()=>o.forEach(d=>d()));return{result:r,undo:c}},Y=e=>function(...t){const s=h,o=[];h=o;const n=e.apply(this,t),r=()=>o.forEach(c=>c());return s?.unshift(r),h=s,{result:n,undo:r}};x.define=e=>P(function(...t){const s=e.apply(this,t),{result:o,undo:n}=s;return h?.unshift(n),{result:o,undo:n}});function x(e){const t=e.constructor.name=="AsyncFunction";return P(t?W(e):Y(e),t)}async function _(e){const t=h;return h=null,{then:o=>e.then(n=>(h=t,o(n)))}}const D=e=>(...t)=>e.forEach(s=>s(...t));function G(e){const t=x.define((n,r)=>{const c=[];let d,m=!1;const p=y=>(queueMicrotask(()=>queueMicrotask(y)),{then:u,timeout:b}),b=async y=>({then:g=>{const v=L=>{clearTimeout(k),e.removeEventListener(n,v,r),g(L)},k=setTimeout(()=>v(null),y);e.addEventListener(n,v,r)}}),u=y=>{if(c.push(y),m&&y(null),!(c.length>1))return d=D(c),e.addEventListener(n,d,r),{then:u}};return{undo:()=>e.removeEventListener(n,d,r),result:{now:()=>(m=!0,{then:u,after:p}),then:u,after:p,timeout:b}}}),s=x.define((n,r={})=>{const c=n[0].toUpperCase()+n.slice(1).toLowerCase(),d=globalThis[c+"Observer"];if(!d)return;let m;const p=[],b=E=>{if(p.push(E),!(p.length>1))return m=new d(D(p)),m.observe(e,r),{then:b}};return{undo:()=>m.disconnect(),result:{then:b}}}),o=(n,r)=>{if(r=="does")return t;if(r=="observes"&&e instanceof Node)return s;const c=r.replace(/s$/,"");return d=>t(c,d)};return new Proxy({does:()=>{},observes:()=>{}},{get:o})}const J=import.meta,K=new Set,w=Symbol("secret"),i=(e,t={})=>Object.assign(a,{name:e,options:t}),$=new Set,R=new Map;let a=null;i[w]={},i[w].getByUUID=e=>{const t=R.get(e);return R.delete(e),a=null,t},i[w].newContext=()=>({name:"",observed:[],properties:[],methods:[],exposed:{internals:Symbol("internals"),attributes:Symbol("attributes"),any:Symbol("any"),elements:Symbol("elements")}}),i.context=e=>{if(a)throw Error(`Yozo: no top-level await`);return $.add(e),a=i[w].newContext(),a.exposed},i.attribute=(e,t={})=>{if(a.observed.push(e),!t.type)return;const s=t.as??e.replace(/-+\w/g,n=>n.slice(-1).toUpperCase()),o=Array.isArray(s)?s:[s];for(const n of o)Q(e,{...t,as:n})},i.shadow=e=>{a.shadow=e},i.form=()=>{a.form=!0},i.property=(e,t)=>{typeof t=="function"&&(t={get:t}),a.properties.push({name:e,descriptor:t})},i.method=(e,t)=>{a.methods.push({name:e,method:t})},i.construct=e=>{a.construct=e},i.connect=e=>{a.connect=x(e)},i.disconnect=e=>{a.disconnect=e},i.done=(e,t)=>{if(!!a&&($.delete(e),R.set(e,a),a=null,t))throw t};export{i as define};let T;const j=new Set,I=e=>{if(!!e)for(const{localName:t}of e.querySelectorAll(":not(:defined)")){const s=customElements.whenDefined(t).then(()=>{j.delete(s),j.size==0&&T()});j.add(s)}};I(document),B.done=new Promise(e=>T=e);async function B(e,{as:t}={}){if(K.has(e.toString()))return;const o=await(await fetch(e)).text(),r=new DOMParser().parseFromString(o,"text/html"),c=r.querySelector("template"),d=r.querySelector("script"),m=r.querySelector("style"),p=m?new CSSStyleSheet:null,b=new Map,u=await X(d.textContent);if(!u)return;const{exposed:U,observed:E,form:O,options:y}=u,{internals:g,attributes:v,any:k,elements:L}=U;t??=u.name;const A=y.extends,N=A?document.createElement(A).constructor:HTMLElement;A||"shadow"in u||(u.shadow={mode:"open"}),p?.replace(m.textContent);const C=class extends N{#e=null;[v]=(...l)=>{const f=new EventTarget;return b.set(l,f),f};[L]=Object.assign(l=>this[g].shadowRoot.querySelector(l),{all:l=>[...this[g].shadowRoot.querySelectorAll(l)]});constructor(){super();let l,f;if(u.shadow){const S=this.attachShadow(u.shadow);l=S,f=S}else l=this,f=document;p&&(f.adoptedStyleSheets=[...f.adoptedStyleSheets,p]),c&&l.append(c.content.cloneNode(!0)),A||(this[g]=this.attachInternals()),u.construct?.call(this,this)}connectedCallback(){this.#e?.undo(),u.connect&&(this.#e=u.connect.do.call(this,this))}disconnectedCallback(){this.#e.undo(),u.disconnect?.()}attributeChangedCallback(l,f,S){if(f===S)return;const z={attribute:l,oldValue:f,value:S},F=()=>new CustomEvent("change",{detail:z});for(const[M,H]of b)(M.includes("*")||M.includes(l))&&H.dispatchEvent(F())}},q=(l,f)=>Object.defineProperty(C.prototype,l,f);for(const{name:l,method:f}of u.methods)q(l,{writable:!0,configurable:!0,value:f});for(const{name:l,descriptor:f}of u.properties)q(l,f);Object.defineProperty(C,"formAssociated",{get:()=>O}),Object.defineProperty(C,"observedAttributes",{get:()=>E}),customElements.define(t,C,y),I(c?.content)}export{B as register};export{x as reversible,_ as until};export{G as when};i[w].url=J.url;function Q(e,t){const{type:s,as:o}=t;s==Boolean?i.property(o,{get(){return this.hasAttribute(e)},set(n){this.toggleAttribute(e,n)}}):i.property(o,{get(){const n=this.getAttribute(e);return n==null?t.default??null:s(n)},set(n){if(n==null)return this.removeAttribute(e);this.setAttribute(e,n)}})}async function X(e){const t=crypto.randomUUID(),s="application/javascript",o=new Blob([Z(e,t)],{type:s}),n=URL.createObjectURL(o);let r;await import(n).catch(d=>r=d),URL.revokeObjectURL(n);const c=i[w].getByUUID(t);if(r)throw r;return c}const Z=(e,t)=>`import { define, when } from "${i[w].url}";
const { internals, attributes, any, elements } = define.context('${t}');
const { construct, connect, disconnect } = define;

${e}

define.done('${t}');
`;
