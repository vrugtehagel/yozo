let h=null;const q=(e,t)=>{const s=t?async function(...o){return e.apply(this,o).result}:function(...o){return e.apply(this,o).result};return s.do=function(...o){const n=this==s?e(...o):e.apply(this,o),{result:c}=n;let r=!1;return{result:c,undo:()=>{r||(r=!0,n.undo())},get undone(){return r}}},s},B=e=>function(...t){const s=h,o=[];h=o;const n=e.apply(this,t);h=s;const c=n.then(l=>(s?.unshift(r),h=s,l)),r=()=>n.then(()=>o.forEach(l=>l()));return{result:c,undo:r}},F=e=>function(...t){const s=h,o=[];h=o;const n=e.apply(this,t),c=()=>o.forEach(r=>r());return s?.unshift(c),h=s,{result:n,undo:c}};x.define=e=>q(function(...t){const s=e.apply(this,t),{result:o,undo:n}=s;return h?.unshift(n),{result:o,undo:n}});function x(e){const t=e.constructor.name=="AsyncFunction";return q(t?B(e):F(e),t)}async function N(e){const t=h;return h=null,{then:o=>e.then(n=>(h=t,o(n)))}}const P=e=>(...t)=>e.forEach(s=>s(...t));function z(e){const t=x.define((n,c)=>{const r=[];let l,p=!1;const b=y=>(queueMicrotask(()=>queueMicrotask(y)),{then:m,timeout:w}),w=async y=>({then:E=>{const g=k=>{clearTimeout(U),e.removeEventListener(n,g,c),E(k)},U=setTimeout(()=>g(null),y);e.addEventListener(n,g,c)}}),m=y=>{if(r.push(y),p&&y(null),!(r.length>1))return l=P(r),e.addEventListener(n,l,c),{then:m}};return{undo:()=>e.removeEventListener(n,l,c),result:{now:()=>(p=!0,{then:m,after:b}),then:m,after:b,timeout:w}}}),s=x.define((n,c={})=>{const r=n[0].toUpperCase()+n.slice(1).toLowerCase(),l=globalThis[r+"Observer"];if(!l)return;let p;const b=[],w=d=>{if(b.push(d),!(b.length>1))return p=new l(P(b)),p.observe(e,c),{then:w}};return{undo:()=>p.disconnect(),result:{then:w}}}),o=(n,c)=>{if(c=="does")return t;if(c=="observes"&&e instanceof Node)return s;const r=c.replace(/s$/,"");return l=>t(r,l)};return new Proxy({does:()=>{},observes:()=>{}},{get:o})}const H=import.meta,W=new Set,v=Symbol("secret"),i=e=>a.name=e,C=new Set,L=new Map;let a=null;i[v]={},i[v].getByUUID=e=>{const t=L.get(e);return L.delete(e),t},i[v].newContext=()=>({name:"",observed:[],properties:[],methods:[],form:!1,exposed:{internals:Symbol("internals"),attributes:Symbol("attributes"),any:Symbol("any"),elements:Symbol("elements")}}),i.context=e=>a?console.log({uuid:e}):(C.add(e),queueMicrotask(()=>{if(C.has(e))throw Error("Yozo: top level await not allowed in custom element definitions")}),a=i[v].newContext(),a.exposed),i.attribute=(e,t={})=>{if(a.observed.push(e),!t.type)return;const s=t.as??e.replace(/-+\w/g,n=>n.slice(-1).toUpperCase()),o=Array.isArray(s)?s:[s];for(const n of o)_(e,{...t,as:n})},i.form=()=>{a.form=!0},i.property=(e,t)=>{typeof t=="function"&&(t={get:t}),a.properties.push({name:e,descriptor:t})},i.method=(e,t)=>{a.methods.push({name:e,method:t})},i.construct=e=>{a.construct=e},i.connect=e=>{a.connect=x(e)},i.disconnect=e=>{a.disconnect=e},i.done=(e,t)=>{if(!!a&&(C.delete(e),L.set(e,a),a=null,t))throw t};export{i as define};async function Y(e,{as:t}={}){if(W.has(e.toString()))return;const o=await(await fetch(e)).text(),c=new DOMParser().parseFromString(o,"text/html"),r=c.querySelector("template"),l=c.querySelector("script"),p=c.querySelector("style"),b=r.getAttribute("mode")??"open",w=r.hasAttribute("delegates-focus"),m=p?new CSSStyleSheet:null,S=new Map,d=await G(l.textContent),{exposed:j,observed:y,form:E}=d,{internals:g,attributes:U,any:k,elements:T}=j;m?.replace(p.textContent),r.removeAttribute("mode"),r.removeAttribute("delegates-focus");const A=class extends HTMLElement{#e=null;[U]=(...u)=>{const f=new EventTarget;return S.set(u,f),f};[T]=Object.assign(u=>this[g].shadowRoot.querySelector(u),{all:u=>[...this[g].shadowRoot.querySelectorAll(u)]});constructor(){super();const u=this.attachShadow({mode:b,delegatesFocus:w});u.append(r.content.cloneNode(!0)),m&&(u.adoptedStyleSheets=[m]),this[g]=this.attachInternals(),d.construct?.call(this,this)}connectedCallback(){this.#e?.undo(),d.connect&&(this.#e=d.connect.do.call(this,this))}disconnectedCallback(){this.#e.undo(),d.disconnect?.()}attributeChangedCallback(u,f,O){if(f===O)return;const $={attribute:u,oldValue:f,value:O},D=()=>new CustomEvent("change",{detail:$});for(const[R,I]of S)(R.includes("*")||R.includes(u))&&I.dispatchEvent(D())}},M=(u,f)=>Object.defineProperty(A.prototype,u,f);for(const{name:u,method:f}of d.methods)M(u,{writable:!0,configurable:!0,value:f});for(const{name:u,descriptor:f}of d.properties)M(u,f);Object.defineProperty(A,"formAssociated",{get:()=>E}),Object.defineProperty(A,"observedAttributes",{get:()=>y}),customElements.define(t??d.name,A)}export{Y as register};export{x as reversible,N as until};export{z as when};i[v].url=H.url;function _(e,t){const{type:s,as:o}=t;s==Boolean?i.property(o,{get(){return this.hasAttribute(e)},set(n){this.toggleAttribute(e,n)}}):i.property(o,{get(){const n=this.getAttribute(e);return n==null?t.default??null:s(n)},set(n){if(n==null)return this.removeAttribute(e);this.setAttribute(e,n)}})}async function G(e){const t=crypto.randomUUID(),s="application/javascript",o=new Blob([J(e,t)],{type:s}),n=URL.createObjectURL(o);return await import(n),URL.revokeObjectURL(n),i[v].getByUUID(t)}const J=(e,t)=>`
import { define, when } from "${i[v].url}";
const { internals, attributes, any, elements } = define.context('${t}');
const { construct, connect, disconnect } = define;
try {

${e}

} catch (error) { define.done('${t}', error); }
define.done('${t}');
`.slice(1);
