@script
	export const layout = 'docs'
	export const title = 'elements'
	export const description = 'Use the ``elements`` variable in component scripts to access the elements inside the template, or to access the shadow root directly.'

h2 Syntax

ui-code
	elements[id];
	elements[tagName];
	elements(selector);
	elements.all(selector);
	elements.shadow;

h3 Parameters
dl
	dt ``id``
	dd > p The exact, or a camelCased version of an element's ``id`` attribute found in the template.
	dt ``tagName``
	dd > p A camelCase version of an element's tag name found in the template.
	dt ``selector``
	dd > p A valid CSS selector string, akin to the first argument to ``.querySelector()``.

h3 Return value
p Return types are relatively straight-forward; ``elements.all()`` returns an array of elements, ``elements.shadow`` yields the shadow root (or ``false``, if the component does not have a shadow root) and the others yield an element, or ``null`` if none was found.

h2 Examples
p Each variation on the syntax behaves slightly different, to cover a wide range of use-cases. For details on each individual method, see below.

ui-callout[type=info]
	p **Note:** When querying for elements in a component, keep in mind that the entire subtree is queried, not only the elements explicitly written in the template.

h3 Property access

p When using the property access syntax, e.g. ``elements.myFoo``, the outcome is cached. The first time a certain property is accessed, the template is queried (like one might do with ``.querySelector()``). If a match is found, it is kept in a cache to avoid re-querying the template unnecessarily. If no match is found, ``null`` is returned, but not kept in the cache; accessing the property will trigger a re-querying of the template until a matching element is found. Note that the matching algorithm prefers matching IDs, but will match the first ID that matches either the kebab-case or exact string given. For example, in this snippet, the element with ``id="my-foo"`` is matched:

ui-code[language=yz]
	<title>my-component</template>
	<template mode="closed">
		<my-foo></my-foo>
		<div id="my-foo"></div>
		<div id="myFoo"></div>
	</template>

p This is because the algorithm first looks for either ``#my-foo`` or ``#myFoo`` (and ``#my-foo`` happens to be matched first) and only tries to look for an element with matching tag name if no ID was matched.

ui-callout[type=warning]
	p **Warning:** Avoid querying conditional elements (i.e. elements with an [``#if``](/docs/components/template/if-else/) or related attribute, or a [``#for…of``](/docs/components/template/for-of/) attribute) or elements inside them with the property access syntax. These elements are not always reused upon re-renders and therefore caching them does more harm than good.

p In practice, the matching rules are not very relevant; for maintainability, IDs (and classes, for that matter) should all have the same casing (either all camelCase or all kebab-case). It is also good to avoid IDs that coincide with a tag name of another element in the same template (since they are supposedly semantically different).

h3 Querying

p If an element needs to be found without caching it, use the function call syntax: ``elements(…)``. This is useful for matching conditional elements, which may be re-constructed across re-renders. For example:

ui-code[language=yz]
	<title>my-component</template>
	<template>
		<div #if="$.visible" id="container">
			<span>Hello world!</span>
		</div>
	</template>
	<script>
	$.visible = true;

	elements('#container'); // null

	connected(() => effect(() => {
		if(!$.visible) return;
		elements('#container'); // <div id="container">…</div>
		elements('span'); // <span>…</span>
	}));
	</script>

p During the construction of the element, the conditional elements don't exist yet, so top-level querying for e.g. ``#container`` yields ``null`` (and the same is true for the property access syntax ``elements.container``). Inside the effect, which is wrapped in a ``connected()`` to make sure the conditional elements are rendered and ready to be queried, we can query the elements safely using the function syntax.

p If we instead used ``elements.container`` and ``elements.span`` inside the effect, then the first time it runs everything would work as expected. However, on subsequent renders, the elements may have been replaced by new elements, while ``elements.container`` and ``elements.span`` have cached an older, now useless, element.

h3 Querying all

h3 Shadow



h2 Usage notes

h2 See also
