@script
	export const layout = 'docs'
	export const title = 'effect()'
	export const description = 'The effect() utility function reactively re-runs a given callback whenever any of its live dependencies changes.'

h2 Syntax

ui-code
	effect(callback);
	effect(callback, scheduler);

h3 Parameters
dl
	dt ``callback``
	dd > p The function to call whenever its live dependencies change. It is also immediately scheduled to run for the first time when calling ``effect()``. On top of tracking its live dependencies, it tracks [``Flow``](/docs/flow/) objects created within the callback, and cleans up the ones created in the last run of the callback before re-running. The callback function does not receive any arguments.
	dt ``scheduler`` [[optional]]
	dd > p An optional function to control when the effect re-runs. By default, ``queueMicrotask`` is used. The scheduler receives a single argument; a function triggering the effect callback.

h3 Return value
p A [``Flow``](/docs/flow/) object in charge of the effect. When the effect re-runs, the flow triggers. Additionally, manually triggering the effect using [``.now()``](/docs/flow/now/) triggers the callback (but has no effect on scheduling). The [``.stop()``](/docs/flow/stop/) and [``.until()``](/docs/flow/until/) methods may be called on this flow to stop the effect.

h2 Examples

h3 Effects in components
p When writing component logic, ``effect()`` really comes in handy. It allows for describing behavior with regards to one of more [``live``](/docs/live/) variables (usually just properties under [``$``](/docs/mods/$/)), without having to worry about the boilerplate or having to explicitly define the dependencies. In this example, let's say we have a custom element that accepts a list of pre-defined comma-separated words, and we want to render them nicely in a list, together with an input for filtering the list.

ui-code[language=yz]
	<title>searchable-list</title>
	<meta attribute="items" type="string">
	<template>
		<input type="text">
		<ul>
			<li #for="item of $.filtered">{{'{'}}{ item }}</li>
		</ul>
	</template>
	<script>
		const { input } = elements;
		live.link($.$searched, input);

		effect(() => {
			if(!$.items) return $.filtered = [];
			const items = $.items.split(',');
			$.filtered = items.filter(item => {
				return item.includes($.searched)
			});
		});
	</script>

p Under the hood, the effect will run the callback and make a note of each live variable being accessed. So, in the above example, it will immediately notice that ``$.items`` is being accessed (inside the ``if`` statement) and register that. Later in the effect, we also access ``$.searched`` (which is bound to the input value); again, the effect makes a note. Now, whenever either ``$.items`` or ``$.searched`` changes, the effect will run again, making sure the ``$.filtered`` variable stays up-to-date. Now let's say we remove the ``items`` attribute, resulting in the initial ``if(!$.items)`` statement to return early. The effect then knows that ``$.items`` is the only dependency, and no longer reacts to changes in ``$.searched``. If we then add the attribute back, ``$.searched`` is once again accessed and added back to the dependencies.

p Also, an important thing to understand is that ``$.filtered`` is __not__ a dependency in the example above. It is being __set__, but not accessed, and as such, its value cannot have an influence on what the callback does.

h3 Describing a process
p In the next example, we have a component called ``regular-polygon`` rendering a regular shape (such as a triangle, square, or hexagon). We will be drawing it on a ``<canvas>`` element.

ui-code[language=yz]
	<title>regular-polygon</title>
	<meta attribute="corners" type="number" default="6">
	<meta attribute="size" type="number" default="200">
	<template mode="closed">
		<canvas></canvas>
	</template>
	<script>
	const { canvas } = elements;
	const context = canvas.getContext('2d');

	effect(() => {
		canvas.width = $.size;
		canvas.height = $.size;
		context.strokeStyle = '#50FA7B';
		context.lineWidth = 5;
		const center = $.size / 2;
		const radius = $.size / 4;
		context.moveTo(center + radius, center);
		for (let corner = 1; corner < $.corners; corner++) {
			const rotation = Math.PI * 2 * corner / $.corners;
			const x = center + radius * Math.cos(rotation);
			const y = center + radius * Math.sin(rotation);
			context.lineTo(x, y);
		}
		context.closePath();
		context.stroke();
	});
	</script>

p We do all of our drawing logic inside of the ``effect()``, because we want the redrawing to be done whenever either of the "size" attribute (i.e. ``$.size``) or the "corners" attribute (i.e. ``$.corners``) changes. The beauty of ``effect()`` here is really the simplicity that it brings. Normally, we'd probably create a ``drawPolygon`` function, with some arguments, and then manually attach the listeners required for the re-drawing whenever one of its arguments changes. With ``effect()``, we only need to describe the drawing process, and that's it.

h3 Scheduling the effect
p The second argument of ``effect()`` opens up the possibility to schedule the effect callback to run at some point later in time, or to run them synchronously. By default, effects wait one microtask after a dependency change to re-run. That essentially allows for making multiple synchronous changes to live variables without triggering the effect over and over. To make this a bit clearer, let's see what happens when we choose to trigger the effect synchronously.

ui-code[language=js]
	const $ = live({ foo: 23 });

	const scheduler = callback => callback();
	effect(() => {
		console.log($.foo);
	}, scheduler);

	setTimeout(() => {
		$.foo = 0;
		$.foo = 5;
		$.foo = 7;
	}, 1000);

p In this example, the effect will run four times; it will first log "23", then wait a second, and then log "0", "5", and "7". If we instead leave out the scheduler (i.e. using the default), then it only logs twice; once "23", then after one second (and a microtask!), "7". Because of this fact, it is often more performance-friendly to use a non-synchronous scheduler, and in most cases, the default is the best option.

h3 Effect only when connected
p Effects can be somewhat optimized by making sure it only runs while a certain component is connected. There are a two main ways to mix [``connected``](/docs/mods/connected/) and ``effect``, and they mean slightly different things. Let's go through them.

p The primary (i.e. this one is usually preferred) way to do it is nesting the ``effect`` call inside the ``connected`` call, like so:
ui-code[language=js]
	connected(() => effect(() => {
		// codeâ€¦
	}));
p This way, the effect is actively looking at its dependencies only while the relevant component is connected. When the element is removed from the DOM, then the effect is stopped automatically. When the component reconnects, the effect re-initializes.

p The second way is nesting the ``connected`` call inside the ``effect`` call. This is often not desired, since ``connected`` creates its own tracking context and so the outer ``effect`` cannot see what is happening inside the ``connected``. It __can__ be useful occasionally for e.g. attaching a certain event handler based on a live variable. For example, let's say we have a component that logs only when a certain event fires, like so:
ui-code[language=yz]
	<title>event-logger</title>
	<meta attribute="event-type" type="string">
	<script>
	// this works
	effect(() => {
		const type = $.eventType;
		connected(() => {
			if(!type) return;
			when(this).does(type).then(() => {
				console.log(`Fired ${type}!`);
			});
		});
	});


	// this does not work
	effect(() => {
		connected(() => {
			if(!$.eventType) return;
			when(this).does($.eventType).then(() => {
				console.log(`Fired ${$.eventType}!`);
			});
		});
	});
	</script>

p The former works because the effect is able to see that ``$.eventType`` is being accessed, and can properly schedule re-running the callback when ``$.eventType`` changes. The latter will run the effect only once, because it doesn't find any dependencies. ``connected`` is already creating its own tracking context (to track flows) and so the ``effect`` only sees what happens before and after the ``connected`` call happens.

h3 Usage notes
p In general, it is safest to wrap ``effect`` calls in ``connected`` calls within component logic. This is because when an effect has external dependencies (that is, one defined outside the custom element's instance) the effect cannot be garbage collected even after releasing all references to the element's instance. This is expected (and necessary) behavior, because external dependencies can still change even after the custom element is no longer in use. Instead, wrapping the effect in a ``connected`` call causes the effect to be cleaned up after the custom element disconnects, and so it doesn't matter where its dependencies came from.
