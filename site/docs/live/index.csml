@script
	export const layout = 'docs'
	export const title = 'live()'
	export const description = 'The ``live()`` function creates a reactive wrapper around a value, to be used in effects, component templates or elsewhere.'

ui-callout[type=info]
	p **Note:** Each custom element already receives [``$``](/docs/component/$/), a live variable for state management in the component instance. As such, using ``live()`` inside component definitions is often not necessary; simply create keys under ``$`` instead. Use ``live()`` for creating external live data, such as a global state object.

h2 Syntax

ui-code
	live(value);

h3 Parameters
dl
	dt ``value``
	dl > p Any primitive value, array or object to create a live (reactive) variable for.

h3 Return value
p A live variable. Live variables are objects that "wrap" an underlying value, and fire certain events whenever properties (or nested properties) are modified. Some contexts, such as inside an [``effect()``](/docs/effect/) or in an [``{{'{'}}{ inlineExpression }}``](/docs/components/template/inline/) in a component's template, react to changes in their live dependencies.

h3 Methods
dl
	dt [``live.get()``](/docs/live/get/)
	dd > p Unwrap a live variable to retrieve its underlying value, or retrieve a value from a property on a live variable.
	dt [``live.set()``](/docs/live/set/)
	dd > p Set the underlying value of a live variable directly.
	dt [``live.delete()``](/docs/live/delete/)
	dd > p Delete the underlying value of a live variable directly.
	dt [``live.link()``](/docs/live/link/)
	dd > p Link a live variable to other live variables, or a non-live source of dynamic data such as an ``<input>`` element.

h3 Events
dl
	dt [``change``](/docs/live/change/)
	dd > p An event that fires whenever the underlying value of a live variable directly changes.
	dt [``deepchange``](/docs/live/deepchange/)
	dd > p An event that is dispatched whenever any nested property of a live variable changes, including the variable itself.
	dt [``keychange``](/docs/live/deepchange/)
	dd > p An event that fires any time a property gets added or deleted on the underlying value of a live variable.

ui-callout[type=warning]
	p **Warning:** It is strongly recommended to start the names of live variables, and live variables only, with a "$". Not only is this helpful in distinguishing live variables from plain (non-live) values, but live variables also respond to accessing a $-prefixed key by returning a live variable for that key. Live, non-dollar-prefixed variable names, as well as dollar-prefixed non-live variables or properties, may lead to nasty and confusing bugs.

h2 Examples

h3 .key and .$key
p When accessing properties on a live variable, the presence or lack of the dollar symbol determines whether a live variable is returned or the value. Specifically, prefixing a key with the dollar symbol results in a live variable around the value at that key. Leaving it out simply acts like a regular property access. In code,

ui-code
	const $data = live({ foo: 23 });

	// $data.$foo is a live variable: Live<23>
	$data.$foo.addEventListener('change', () => {
		console.log('foo changed!');
	});

	// $data.foo is just a value; this sets .foo to 24
	$data.foo = $data.foo + 1;
	// "foo changed!"

p If the live variable is wrapping an object that happens to have keys that are already dollar-prefixed, then it is not possible to directly get their value through a regular property access. Instead, use [``live.get()``](/docs/live/get/) with the key as second argument.

ui-code
	const $data = live({ foo: 23, $bar: 'baz' });

	console.log($data.bar); // undefined
	console.log($data.$bar); // Live<undefined>
	console.log($data.$$bar); // Live<"baz">
	console.log(live.get($data, '$baz')); // "baz"

p When setting a nested property of a live variable, it is strongly recommended to keep the access chain live (dollar-prefixing all intermediate keys), with the exception of the last key. This is because contexts reacting to changes in live variables can only see changes as far as the first non-live access. For example:

ui-code
	const $data = live({ foo: { bar: { baz: 'qux' } } });
	$data.$foo.$bar.baz = 'quux'; // correct

	$data.$foo.$bar.$baz = 'quux'; // sets the "$baz" key
	$data.foo.bar.baz = 'quux'; // loses reactivity

p The first is correct since each intermediate live variable is created, and the last ``.baz`` can be seen by any contexts watching. The second simply sets the ``$baz`` key instead of the ``baz`` key (probably a mistake). The last one is a bit more subtle. It first retrieves ``$data.foo`` (and that becomes a dependency if it is in a tracking context) but after that they are simple property accesses on plain objects, which ``live()`` cannot see. It then also has no idea the ``baz`` property was set, so it cannot trigger a change event. On the other hand, the first (correct) version to set the ``baz`` property does __not__ add a dependency to tracking contexts, because it is setting a value, rather than using one.

p Lastly, it is not recommended to use symbols as keys on live objects. While symbol keys remain reactive, it is not possible to retrieve the live variable around a value at symbol, since symbols cannot be prefixed with a "$".
